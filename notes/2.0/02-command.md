# vue command

## basic

#### v-cmd

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * vue 相关指令         // 特点: 前缀( v- )
 *
 *
 * 具有特殊含义、用于有特殊功能的特性 attribute
 *
 * 可以直接使用在 data 中的数据
 */

<div v-cmd>{{ data }}</div>


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### v-pre

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * v-pre
 *
 *
 * 跳过元素和身和子元素的编译过程，跳过没有指令的节点，加速编译
 *
 * 可以用来显示原始 Mustache 标签
 */

// <span v-pre>{{ msg }}</span>                        <!-- 不会被 vue 编译 -->


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### v-cloak

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * v-cloak              // 解决页面闪烁
 *
 *
 * 会一直保留在 dom 元素上，直到 dom 编译结束后，会自动去除
 *
 * 和 CSS 规则如 [v-cloak] { display: none } 一起用时，这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕
 */

<div v-cloak>v-clock: {{ msg }}</div>       <!-- 会一直保留在 dom 元素上，直到 dom 编译结束后，会自动去除 -->


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### v-once

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * v-once
 *
 *
 * 只渲染元素一次，随后的重新渲染，元素及其所有的子节点将被视为静态内容并跳过
 *
 * 可以用于优化更新性能
 */

<div v-once>v-once: {{ msg }}</div>     <!-- 只渲染元素一次，随后的重新渲染，元素及其所有的子节点将被视为静态内容并跳过 -->


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### v-text

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * v-text
 *
 *
 * 1) 更新 元素内容 textContent / dom.innerText ",
 * 2) 更新 插值表达式 {{}} ",
 * 3) 更新 v-text 替换元素中的所有文本 ",
 * 4) 更新 {{}} ( mustache 胡子语法 ): 仅替换自己，不清空内容 "
 */


<div v-text="msg">v-text: 该内容会被清空并覆盖</div>       <!-- 和下面的一样 -->
<div v-text="msg">----</div>                           <!-- 和下面的一样 -->
<div>{{msg}}</div>


// <div>----{{msg}}----</div>              <!-- 只替换自己"{{msg}}"，不清空元素内容 -->


//-------------------------------------------------------------------------------------------------------------------//


/**
 * textContent( IE8+ ) vs innerText( IE 原生 )
 *
 *
 * textContent: 获取指定 dom 元素下的所有元素节点, innerText: 仅获取文本节点
 * innerText 受到 css 影响，不获取隐藏元素的文本
 * innerText 受到 触发页面重新渲染
 * textContent: 标准方法, innerText: IE 引入
 */

// <div id="demo">
//     hello world
// <div>test</div>
// </div>

const demo = document.getElementById("demo");

console.log(demo.textContent);              // 包含所有节点
// "empty node"
// "empty node"
// hello world
// test


console.log(demo.innerText);                // 仅包含文本节点
// hello world
// test


//-------------------------------------------------------------------------------------------------------------------//


// textContent vs innerText

设置文本替换时，两者都会把指定节点下的所有子节点也一并替换掉

textContent 会获取所有元素的内容，包括 <script> 和 <style> 元素，然而 innerText 不会

innerText 受 CSS 样式的影响，并且不会返回隐藏元素的文本，而textContent会

由于 innerText 受 CSS 样式的影响，它会触发重排（reflow），但textContent 不会

innerText 不是标准制定出来的 api，而是IE引入的，所以对IE支持更友好。textContent虽然作为标准方法但是只支持IE8+以上的浏览器，在最新的浏览器中，两个都可以使用。

综上，Vue这里使用 textContent 是从性能的角度考虑的。


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### v-html

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * v-html               // 谨慎使用，避免 XSS 攻击
 *
 *
 * 内容按普通 HTML 插入，不会作为 Vue 模板进行编译
 *
 * 仅作用于可信的内容上使用，不要用于用户提交的内容
 *
 * 更新元素的 innerHTML, 仅可插入字符串，不可插入模版字符串
 */


// <input type="text"/>
// <button>点击</button>
// <div id="app1">
//     <div v-html="msg"></div>
// </div>

const vm = new Vue({
    el: '#app1',
    data: {
        msg: 'hello world'
    }
});

const oInput = document.getElementsByTagName('input')[0];
const oButton = document.getElementsByTagName('button')[0];

let msg = null;

oButton.onclick = function () {

    vm.msg = oInput.value;                  // 若此时用户有意将 死循环输入，则会导致网站进入死循环
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

## condition

#### v-if

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * v-if                         // 页面重绘
 *
 *
 * 根据某个条件，判断是否要展示指定 dom 元素
 */


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//



/**
 * v-else-if                    // 当前指令之前必须有 v-if
 *
 *
 * 表示 v-if 的 v-else-if 块
 */


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * v-else                       // 当前指令之前必须有 v-if 或 v-else-if
 *
 *
 * 表示 v-if 的 v-else 块
 */

//-------------------------------------------------------------------------------------------------------------------//


<div v-if="type === 'A'">just do it</div>

<div v-else-if="type === 'B'">just so so</div>

<div v-else-if="type === 'C'">just so so</div>

<div v-else="type === 'C'">just so so</div>


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### v-show

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * v-show                       // 切换 display: none <=> block
 *
 *
 * 相较 v-if，并不会重绘页面，降低了部分性能消耗
 */


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### v-if vs v-show

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// v-if vs v-show

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


v-if   是惰性的，如果在初始渲染时条件为假，则什么也不做，
       直到条件第一次变为真时，才会开始渲染条件块

v-show 则不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


v-if 有更高的切换开销，v-show 有更高的初始渲染开销，如果需要非常频繁地切换
则使用 v-show 较好，如果在运行时条件很少改变，则使用 v-if 较好

v-show 不支持 <template> / v-else / v-else-if

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

## v-bind:prop | :prop

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * v-bind:prop = val <===> :prop = val          // 静态绑定特性
 *
 * v-bind:[prop] = val                          // 动态绑定特性( vue 2.6.0+ )
 *
 *
 * 动态绑定一个或多个特性
 */


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * 绑定单个特性
 *
 *
 */

<!-- 绑定一个属性 -->
<img v-bind:src="imageSrc">

<!-- 动态特性名 (2.6.0+) -->
<button v-bind:[key]="value"></button>

<!-- 缩写 -->
<img :src="imageSrc">

<!-- 动态特性名缩写 (2.6.0+) -->
<button :[key]="value"></button>

<!-- 内联字符串拼接 -->
<img :src="'/path/to/images/' + fileName">


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * 绑定多个特性
 *
 *
 * 没有参数时，可以绑定到一个包含键值对的对象
 * 注意此时 class 和 style 绑定不支持数组和对象
 */

<!-- 绑定一个有属性的对象 -->
// <div v-bind="{ id: someProp, 'other-attr': otherProp }"></div>


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * 针对 class & style 特性的绑定时
 *
 *
 * 字符串的绑定麻烦且易错，所以 vue 做了增强，表达式除了字符串之外，还可以是 数组 或 对象
 */


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### bind class

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 绑定 class
 *
 *
 * 不会和静态的 class 冲突，vue 编译后的 className 仅会添加进静态元素的 class
 */

<div :class="{ red: isRed }">test - 1</div>                         <!-- 绑定对象 -->

<div :class="[ red, green ]">test - 2</div>                         <!-- 绑定数组 -->

<div :class="[ red, green ]" class="red">test - 2</div>             <!-- 绑定的特性 class 可以和静态的 class 共存-->

<div :class="[ {red: isRed}, {green: isGreen} ]">test - 3</div>     <!-- 数组中可以使用对象语法 -->


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### bind style

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 绑定 style
 *
 *
 * 自动补全浏览器兼容前缀( 当同一特性时 )
 */

// 碰到 text-align 用横线连接的字符名车时，必须使用 小驼峰命( demoName )，增加引号( 'demo-name' )

<div :style="{ color: 'red', width: '100px', backgroundColor: 'yellow', 'text-align': 'left' }">hello world</div>

<div :style="styleObjA">hello world</div>                          <!-- 绑定对象 -->

<div :style="[ {prop:val}, {prop:val} ]">hello world</div>             <!-- 绑定数组: 数组中可引入多个对象 -->


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 只会渲染数组中最后一个被浏览器支持的值，若浏览器支持不带浏览器前缀的 flexbox，那么就只会渲染 display: flex。

<div v-bind:style="{ display: ['-webkit-box', '-ms-flexbox', 'flex'] }"></div>


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### modifier

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 修饰符
 * 
 * 
 * 修饰符 (modifier) 是以英文句号 . 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定
 */


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * camel                        // 使用 camel 时，属性必须使用短横线连接
 *
 *
 * vue 在编译过程中，会将特性的名称转化为 小写，解决 部分需要特性需要大写的问题，
 *
 * 会将 短字符线连接的 特性名称，转变为 小驼峰命名
 *
 * demo-name ---> demoName
 */

<svg :view-box.camel="viewBox"></svg>               <!-- 使用 camel 时，属性必须使用短横线连接 -->


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * prop
 *
 *
 * 用于绑定 dom 属性
 */

<div :text-content.prop = "'alpha'" ></div>                     <!--绑定的特性将作为 属性使用 &ndash;&gt;-->

for (let key in demo) {

	console.log(key);               // 循环出元素身上包含的属性
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

## v-on:event | @event

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 为什么在 html 中监听事件
 *
 *
 */

1) 便于查看 dom 绑定事件的类型

2) 简化了 dom 绑定事件的流程，便于测试

3) 当 viewModel 被销毁时，所有事件处理器都会被自动删除( 无需担心如何清理他们 )


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### v-on

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * v-on:event  === @event
 *
 *
 * 监听 DOM 事件
 */

// <button v-on:click="addCounter(5, $event)">点击 +1</button>         绑定静态事件

// <button v-on:[event]="addCounter(5, $event)">点击 +1</button>       绑定动态事件



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * methods: { method ... }
 *
 *
 * methods 中的函数，会直接代理给 Vue 的实例对象
 */


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * event(param, $event)              // e.target === $event
 *
 *
 * 将 $event 作为参数传入后，可获取 事件对象
 */


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

### modifier

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 事件修饰符
 *
 *
 */

1) 使用修饰符时，顺序很重要。相应的代码会以同样的顺序产生

   v-on:click.prevent.self       // 会阻止所有的点击的默认事件
   v-on:click.self.prevent       // 只会阻止对元素自身点击的默认事件


2) 不要把 .passive 和 .prevent 一起使用，因为 .prevent 将会被忽略，同时浏览器可能会向你展示一个警告。


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### .stop

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * event.stop
 * 
 * 
 * 阻止事件冒泡
 */


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### .prevent

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * event.prevent        // 调用 e.preventDefault();
 * 
 * 
 * 阻止元素默认事件
 */


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### .capture

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * event.capture
 * 
 * 
 * 触发 "事件捕获"
 */


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### .self

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * event.self
 * 
 * 
 * 仅触发自身的事件( 但仍然会触发事件冒泡 )
 */


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### .once

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * event.once
 * 
 * 
 * 事件只触发一次 ( vue2.1.4+ )
 */


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### .passive

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * event.passive
 * 
 * 
 *  设置 addEventListener 中的 passive 选项
 *  能够提升移动端的性能
 *  告知浏览器是否 关闭/触发 元素的默认事件
 */

即使在触发触摸事件时，执行了一个空的函数，也会让页面卡顿。
因为浏览器不知道监听器到底会不会阻止默认事件，所以浏览器要等到执行完整个函数后，才能决定是否要滚动页面。
passive事件监听器，允许开发者告诉浏览器，监听器不会阻止默认行为，从而浏览器可以放心大胆的滚动页面，
这样可以大幅度提升移动端页面的性能，因为据统计只有20%的触摸事件会阻止默认事件


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### system modifier

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 系统修饰键
 *
 *
 * 可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器
 * 修饰键与常规按键不同，在和 keyup 事件一起用时，事件触发时修饰键必须处于按下状态
 * 换句话说，只有在按住 ctrl 的情况下释放其它按键，才能触发 keyup.ctrl
 * 而单单释放 ctrl 也不会触发事件。如果你想要这样的行为，请为 ctrl 换用 keyCode：keyup.17
 */


//
//
// .ctrl
// .alt
// .shift
// .meta


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * exact            // vue 2.5.0+
 *
 *
 * 允许你控制由精确的系统修饰符组合触发的事件
 */


<!-- 即使 Alt 或 Shift 被一同按下时也会触发 -->
// <button @click.ctrl="onClick">A</button>

<!-- 有且只有 Ctrl 被按下的时候才触发 -->
// <button @click.ctrl.exact="onCtrlClick">A</button>

<!-- 没有任何系统修饰符被按下的时候才触发 -->
// <button @click.exact="onClick">A</button>


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### .key

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




/**
 * @mouseEvent.key = Fn                         // key 必须是短横线分隔，小驼峰命名无法识别
 *
 *
 * keyCode 的事件用法已经被废弃了，并可能不会被最新的浏览器支持
 *
 *
 * Vue.config.keyCodes.key = val                // 自定义按键别名
 *
 *
 */


// 为了在必要的情况下支持旧浏览器，Vue 提供了绝大多数常用的按键码的别名
//
// .enter
// .tab
// .delete
// .esc
// .space
// .up
// .down
// .left
// .right


Vue.config.keyCodes = {

    v: 86,
    f1: 112,

    // 小驼峰 不可用
    mediaPlayPause: 179,

    // 取而代之的是 短横线分隔 且用双引号括起来
    "media-play-pause": 179,

    up: [38, 87]
};


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### mouse modifier

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 鼠标按钮修饰符              // vue 2.2.0+
 *
 *
 * .left
 *
 * .right
 *
 * .middle
 */


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```
# Vue

## install vue

### install vue cli

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * Install Vue 
 * 
 * 
 * 8.11.0+
 */

npm install -g @vue/cli                         // vue 命令行工具

npm install -g @vue/cli-service-global          // 快速原型开发工具


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

### vue module scoped

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * scoped
 * 
 * 
 * 带有 scoped 特性的标签仅作用域当前的 component
 */

<template scoped>

    // hteml

</template>


<script scoped>

    // js

</script>


<style scoped>

    // css

</style>


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

### create vue app

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * command create vue
 * 
 * 
 * 
 */


vue create [name]


? Please pick a preset                                              // 请选择一个预设

? Check the features needed for your project                        // 检查项目所需的功能

? Where do you prefer placing config for Babel, ESLint, etc.?       // 希望在哪里放置Babel，ESLint等的配置？

    > In dedicated config files             // 在专用配置文件中

    > In package.json                       // 在package.json中


//-------------------------------------------------------------------------------------------------------------------//


/**
 * ui create vue
 * 
 * 
 */

vue ui


//-------------------------------------------------------------------------------------------------------------------//


/**
 * 删除存储的默认配置文件
 * 
 * 
 * 
 */

./root/.vuerc


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

## vue basic

### new Vue();

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * new Vue(options?: obj): vue;
 *
 *
 * 返回一个 vue 实例对象
 */


//-------------------------------------------------------------------------------------------------------------------//


// vueModule - usage 1

const vueModule1 = new Vue({

    /**
     * el: element | selector;
     *
     *
     * 用于设置 vue-module 控制的区域
     */

    el: '#vue-module',

    /**
     * data: obj;
     *
     *
     * 用于存放需要用的数据( 响应式数据 )
     */

    data: {
        msg: 'hello world'
    }
});


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// vueModule - usage 2

const vueModule2 = new Vue();

/**
 * $mount(dom)               //  作用和 el 一致，用于配置指定的控制元素
 *
 *
 * 在项目中有时要进行延迟挂载使用
 */

vueModule2.$mount(#vue-module);


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

### vm.data

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * data
 *
 *
 * 用于存放需要用到的数据( 数据为响应式 )
 */

const vm = new Vue({

    el: '#app',
    data: {

        'alpha': 'just do it'
    }
});


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

### {{ variable | express }}

#### basic variable/express

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * {{ content: variable | express }}                    // 插值表达式
 *
 *
 * variable: 除了在data 中声明的变量( 无法使用在 data 中 未声明的变量 )
 *           还可以直接填入 number, string, boolean, object, undefined, null
 *
 * express: 运算表达式
 *          逻辑表达式
 *          三元表达式
 *          函数表达式
 */


//-------------------------------------------------------------------------------------------------------------------//

<!-- variable: number, string, boolean, object, undefined, null -->

{{ msg }}                                   <!-- variable -->

{{ 'number: ' + 5201314 }}                  <!-- number -->
{{ 'string' }}                              <!-- string -->
{{ true }}                                  <!-- boolean -->
{{ ['a','b','c'] }}                         <!-- array -->
{{ {name:'alpha',age:18} }}                 <!-- object -->


<!-- basic express -->

{{ 1 + 1 }}
{{ !0 }}
{{ 1 + 1 === 2 ? 'do it' : 'just' }}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### unrenderable state

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/** 下列情况无法重新渲染数据 **/


//-------------------------------------------------------------------------------------------------------------------//

1) 未经声明的: 未在 js 中声明的属性，无法通过 数据劫持 所监听

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * 未声明数据不报错？
 *
 *
 */

- 在作用域上找不到时: throw err

- 在原型链上找不到时: undefined


//-------------------------------------------------------------------------------------------------------------------//


2) 未经使用的: 渲染DOM( 为了降低消耗性能，在 js 中未使用的 DOM 不做监听 )


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * vm-response
 *
 *
 * vue 2.0: Object.defineProperty           // 数据劫持
 * vue 3.0: proxy
 */

创建 new vm 时，vm 会把 options.data 中的属性赋予到 当前捆绑的元素上，当数据改变，页面会重新渲染


//-------------------------------------------------------------------------------------------------------------------//

/**
 * 3) 数组: 通过索引更改数组的子项
 *         更改数组的长度
 *
 *         resolve: push(), pop(), shift(), unshift(), splice(), sort(), reverse()
 */


// 设置/更新

vm.$set(tar: dom, key: str, val: str);          
Vue.set(tar, key, val);

// 删除

vm.$delete(tar: dom, key: str, val: str);       
Vue.delete(tar, key, val);


//-------------------------------------------------------------------------------------------------------------------//


/**
 * 4) 对象: 增加对象的子项
 *         删除对象的子项
 *
 */

// 设置/更新

vm.$set(tar: dom, key: str, val: str);
Vue.set(tar, key, val);

// 删除

vm.$delete(tar: dom, key: str, val: str);
Vue.delete(tar, key, val);


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### vue response --!important

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * vm-response
 * 
 * 
 * vue 2.0: Object.defineProperty           // 数据劫持
 * vue 3.0: proxy
 */

创建 new vm 时，vm 会把 options.data 中的属性赋予到 当前捆绑的元素上，当数据改变，页面会重新渲染


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * 为什么 data 会直接出现在 vm 实例对象中 ?
 *
 *
 */

当创建 vue 实例对象时，vue 会将 data 中的成员代理给 vue 实例

目的是为了实现响应式，监控数据变化，执行某个监听函数


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * const vm = new Vue(options);
 *
 *
 */

// options.data 的属性会被赋予到 实例对象上

vm.prop === options.data.prop;          


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * vue 实例对象中，除了data 外的属性和方法
 *
 *
 * 为了更好的解决属性名冲突
 */

1) $publicProp: 提供给开发者使用的属性或方法

2) _privateProp: vue 私有的属性和方法


// console.log(Vue);
//
// Vue
// $attrs: (...)
// $children: []
// $createElement: ƒ (a, b, c, d)
// $el: div#vm-render
// $listeners: (...)
// $options: {components: {…}, directives: {…}, filters: {…}, el: "#vm-render", _base: ƒ, …}
// $parent: undefined
// $refs: {}
// $root: Vue {_uid: 1, _isVue: true, $options: {…}, _renderProxy: Proxy, _self: Vue, …}
// $scopedSlots: {}
// $slots: {}
// $vnode: undefined
// alpha: (...)
// msg: (...)
// _c: ƒ (a, b, c, d)
// _data: {__ob__: Observer}
// _directInactive: false
// _events: {}
// _hasHookEvent: false
// _inactive: null
// _isBeingDestroyed: false
// _isDestroyed: false
// _isMounted: true
// _isVue: true
// _renderProxy: Proxy {_uid: 1, _isVue: true, $options: {…}, _renderProxy: Proxy, _self: Vue, …}
// _self: Vue {_uid: 1, _isVue: true, $options: {…}, _renderProxy: Proxy, _self: Vue, …}
// _staticTrees: null
// _uid: 1
// _vnode: VNode {tag: "div", data: {…}, children: Array(1), text: undefined, elm: div#vm-render, …}
// _watcher: Watcher {vm: Vue, deep: false, user: false, lazy: false, sync: false, …}
// _watchers: [Watcher]
// $data: (...)
// $isServer: (...)
// $props: (...)
// $ssrContext: (...)
// get $attrs: ƒ reactiveGetter()
// set $attrs: ƒ reactiveSetter(newVal)
// get $listeners: ƒ reactiveGetter()
// set $listeners: ƒ reactiveSetter(newVal)
// get alpha: ƒ proxyGetter()
// set alpha: ƒ proxySetter(val)
// get msg: ƒ proxyGetter()
// set msg: ƒ proxySetter(val)
// __proto__: Object


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### vue render

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 无法监听和渲染不存在的数据
 *
 *
 */

1) 更改的数据必须是存在的数据，否则不能重新渲染页面，因为 vue 无法监测不存在的数据

2) 更改的数据必须是已渲染过的数据，否则从性能角度考虑( 节省性能 )，不会重新渲染页面


//-------------------------------------------------------------------------------------------------------------------//


/**
 * 更改数据后，页面是否会立即重新渲染            // 渲染页面是异步的
 *
 *
 * 同步执行栈执行完毕后，会执行异步队列
 */

vue 更新 DOM 的操作是异步执行的，只要侦听到数据变化，将开启一个异步队列，
如果一个数据被多次变更，那么只会被推入到队列中一次，这样可以避免不必要的计算和DOM操作


同步执行栈 <--- ( 异步队列 <--- 微任务 <--- 宏任务 )


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### vm.$nextTick(); & Vue.nextTick();

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * vm.$nextTick(); & Vue.nextTick();                // 在页面重新渲染，DOM更新后，会立刻执行该方法
 *
 *
 * vue: 等待主线程，异步任务会等待 同步执行栈 处理完所有任务后再执行
 * rect: 让出主线程，主线程有空就会执行异步任务
 *
 ** vue 异步渲染页面
 */


vm.$nextTick(): promise;                         // this => vm = new Vue();
Vue.nextTick(): promise;                         // this => window


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// vm.$nextTick vs Vue.nextTick

Vue.nextTick 内部函数的 this -> window
vm.$nextTick 内部函数的 this -> Vue实例对象



Vue.nextTick(function () {

    console.log(this); // window
});

vm.$nextTick(function () {

    console.log(this); // vm实例
});


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### vue 2.0 response principle

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * vue 响应式原理
 *
 *
 * Object.defineProperty        // 监听指定对象属性的改变( 无法监听对象的'增删属性' )
 */


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


异步任务分为 宏任务( macro）和 微任务( micro)
宏任务比较慢( 如setTimeout等 )，微任务比较快( 如 Promise.then(); 等)
微任务在前，宏任务在后( eventloop，事件环 )

// 控制台打印顺序：promise > timeout

setTimeout(() => {

	console.log('timeout');
	
}, 0);

Promise.resolve().then(() => {

	console.log('promise');
});


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 在 nextTick 的实现源码中，会先判断是否支持微任务，不支持后，才会执行宏任务


if (typeof Promise !== 'undefined') {

	// 微任务
	// 首先看一下浏览器中有没有promise
	// 因为IE浏览器中不能执行Promise
	const p = Promise.resolve();

} else if (typeof MutationObserver !== 'undefined') {

	// 微任务
	// 突变观察
	// 监听文档中文字的变化，如果文字有变化，就会执行回调
	// vue的具体做法是：创建一个假节点，然后让这个假节点稍微改动一下，就会执行对应的函数
	
} else if (typeof setImmediate !== 'undefined') {

	// 宏任务
	// 只在IE下有
	
} else {

	// 宏任务
	// 如果上面都不能执行，那么则会调用setTimeout
}


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 缺点: 

    1) 需要递归监听对象中的对象
    
    2) 选择不用 Object.defineProperty 监测数组，因为性能的消耗和用户体验不成正比
    
    3) 监听不到数组不存在的索引变化
    
    4) 监听不到数组长度的改变
    
    5) 监听不到对象的增删


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```








### Virtual DOM

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * createNodeDescription            // virtual node
 * 
 * 
 * Vue 通过建立一个 虚拟DOM 来追踪自己要如何改变 真实DOM
 * 
 * vNode 包含 Vue 页面中所有需要渲染的节点描述信息
 * 
 *
 * * <template><template/> 和 render()，不能共存
 */


render(createElement: CreateElement, context: RenderContext<Props>): VNode | VNode[] {

}


//-------------------------------------------------------------------------------------------------------------------//


/**
 * 在 vue 中 template 和 render 的优先级 
 * 
 * 
 */


<template></template>           // 优先级 - 1

export default {

    template: ``,               // 优先级 - 3
    
    render() { },               // 优先级 - 2
}


//-------------------------------------------------------------------------------------------------------------------//


/**
 * createElement(tagName, ?context, ?subVNode): ;
 * 
 * 
 * @tagName: string-tagName | string-component              // 标签名 | 组件名
 * 
 * @context: { key: value }                                 // 与模板中属性对应的数据对象
 * 
 * @subVNode: VNode | VNode[]                               // 子级虚拟节点
 */


//-------------------------------------------------------------------------------------------------------------------//


{
    /**
     * v-bind:class
     * 
     * 
     * 接受一个字符串、对象或字符串和对象组成的数组
     */
    
    class: {
    
        foo: true,
        bar: false
    },


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//

    
    /**
     * v-bind:style
     * 
     * 
     * 接受一个字符串、对象，或对象组成的数组
     */
    
    style: {
        color: 'red',
        fontSize: '14px',
    },
    
    
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//

    
    /**
     * 普通的 HTML attribute
     * 
     * 
     * 
     */
    
    attrs: {
        id: 'foo',
    },


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//
    
    
    /**
     * 组件 prop
     * 
     * 
     * 
     */

    props: {
        myProp: 'bar',
    },
    

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//

    
    /**
     * DOM属性
     * 
     * 
     * 
     */

    domProps: {
        innerHTML: 'baz',
    },
    

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


    /**
     * 事件监听器
     * 
     * 
     * 不支持如“v-on:keyup.enter”这样的修饰器
     */

    on: {
    click: this.onClick
    },
    

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


    /**
     * 仅用于组件，用于监听原生事件
     * 
     * 
     * 不是组件内部使用 vm.$emit 触发的事
     */
    
    nativeOn: {
    click: this.nativeClickHandler
    },


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//
    
    
    /**
     * 自定义指令
     * 
     * 
     * 注意，无法对 `binding` 中的 `oldValue`赋值，因为 Vue 已经自动为你进行了同步
     */

    directives: [
    {
      name: 'my-custom-directive',
      value: '2',
      expression: '1 + 1',
      arg: 'foo',
      modifiers: {
        bar: true
      }
    }
    
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


    ],

    /**
     * key
     * 
     * 
     * 
     */
    
    key: 'myKey',
    

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


    /**
     * ref
     * 
     * 
     * 如果在渲染函数中给多个元素都应用了相同的 ref 名，那么 `$refs.myRef` 会变成一个数组
     */
    
    ref: 'myRef',
    refInFor: true


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//
    
    
    /**
     * 作用域插槽
     * 
     * 
     * 格式为：{ name: props => VNode | Array<VNode> }
     * 如果组件是其它组件的子组件，需为插槽指定名称
     */
    
    slot: 'name-of-slot',
    scopedSlots: {
        default: props => createElement('span', props.text)
    },
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

### JSX

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * JSX
 * 
 * 
 * JS + XML(html)
 */

render() {

    return (
    
        <html>                  // "<" ">" 中放置 html
        
        {js}                    // "{" "}" 中放置 javascript
    )
}


//-------------------------------------------------------------------------------------------------------------------//


/**
 * v-text
 * 
 * 
 * 
 */

<div domPropsInnerHTML="<a>href</a>"/>


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * v-html
 * 
 * 
 * 
 */

<div domPropsInnerHTML="<p>i am a p</p>"></div>


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * v-show
 * 
 * 
 * jsx支持v-show指令, 但需要借助 js 变量
 */

<div v-show={this.show}></div>


//-------------------------------------------------------------------------------------------------------------------//


/**
 * v-if
 * 
 * 
 * 
 */

{true && <div>div</div>}                                // v-if

{true ? <div>div</div> : <span>span</span>}             // v-if + v-else


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * 当处理过程相对繁琐时，可借用 methods 使用多种条件判断
 * 
 * 
 * 
 */


methods: {

    vIf() {                                             // v-if + v-else-if + v-else
    
        if (this.num === 1) {
    
            return <div>1</div>
    
        } else if (this.num === 2) {
    
            return <span>2</span>;
    
        } else {
    
            return <div>3</div>;
        }
    },
}

//-------------------------------------------------------------------------------------------------------------------//


/**
 * v-for
 * 
 * 
 * 
 */

{[1, 2, 3].map(item => (<div key={item}>{ item }</div>))}


//-------------------------------------------------------------------------------------------------------------------//


/**
 * v-on
 * 
 * 
 * 
 */


<button on-click={this.handleClick}>click</button>

<button onClick={this.handleClick}>click</button>


<base-demo nativeOnClick={this.handleClick}/>                           // 监听原生事件

<button onClick={() => {this.handleClick(1)}}>click</button>            // 传参


//-------------------------------------------------------------------------------------------------------------------//


/**
 * v-bind
 * 
 * 
 * 
 */

<div
    class={['a', 'b']}
    style={{fontSize: '14px', color: 'red'}}
>
    v-bind
</div>


//-------------------------------------------------------------------------------------------------------------------//


/**
 * v-model
 * 
 * 
 * 有相应的插件 支持 v-model，可直接使用
 */

<input v-model={this.content}/>{this.content}


//-------------------------------------------------------------------------------------------------------------------//


/**
 * v-slot
 * 
 * 
 * 
 */

<base-slot>

    <div slot="default">默认插槽</div>
    <div slot="header">具名header插槽</div>

</base-slot>


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * scopedSlots
 * 
 * 
 * 
 */

// 1
// 
<base-slot-h-w {...{scopedSlots: {default: (props) => props.text}}} />


// 2
// 
const scopedSlots = {

    default: props => <span>{props.text}</span>
};

<base-slot-h-w {...scopedSlots} />


//-------------------------------------------------------------------------------------------------------------------//


/**
 * 不常用，无替代方案
 * 
 * 
 * v-pre
 * v-cloak
 * v-once
 */


//-------------------------------------------------------------------------------------------------------------------//


/**
 * ref
 * 
 * 
 * 
 */

<input ref="input"/>

{this.arr1.map(item => <div ref="xx" key={item}>{item}</div>)}

{this.arr2.map(item => <div ref="xx" refInFor={true} key={item}>{item}</div>)}


//-------------------------------------------------------------------------------------------------------------------//


/**
 * 自定义指令
 * 
 * 
 * 
 */

render () {

  // 1
  return (
    <input v-splice={{value: this.value, modifiers: {number: true }}}/>
  )


  // 2
  const directives = [
    { 
      name: 'splice', 
      value: this.value,  
      modifiers: {number: true }
    }
  ];

  return (
    <div {...{ directives} }></div>
  )
}


//-------------------------------------------------------------------------------------------------------------------//


/**
 * 过滤器
 * 
 * 
 * 
 */

<!-- 正常使用过滤器 -->
<div>{{ msg | capitalize }}</div>

<!-- 在jsx中使用过滤器 -->
<div>{ this.$options.filters('capitalize')(this.msg) }</div>


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```
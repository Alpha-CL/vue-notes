## router

### what is router

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 什么是路由
 * 
 * 
 * 路由是根据不同的 "url address" 展现不同的内容或页面
 */


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * 什么时候使用前端路由
 * 
 *  
 * 前端路由更多用在单页应用上，也就是SPA(Single Page Web Application)，在单页面应用中，大部分页面结果不变，只改变部分内容的使用
 */


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

### install vue-router

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 安装路由
 * 
 * 
 * npm install vue-router
 */


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

### init use vue-router

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/** 1. 引入路由 **/

import VueRouter from 'vue-router';


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/** 2. 使用路由 **/

Vue.use(VueRouter);


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/** 3. 定义路由组件 **/

const Foo = { template: '<div>foo</div>' }
const Bar = { template: '<div>bar</div>' }


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/** 4. 定义路由 **/

const routes = [

    { path: '/foo', component: Foo }
    { path: '/bar', component: Bar }
];


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/** 5. 创建 router 实例，配置 routes **/

const router = new VueRouter({

    routes
});


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/** 6. 创建和挂在根实例 **/

const app = new Vue({

    router

}).$mount('#app');


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

### router mode

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


const router = new VueRouter({

    mode: 'hash',           // default
});


//-------------------------------------------------------------------------------------------------------------------//


/**
 * hash-mode                // vue-router 默认 hash-mode
 * 
 * 
 * 1) 页面地址会增加 hash 
 * 
 * 2) 页面跳转不会重新加载
 */


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * history-mode             // history.pushState API 
 * 
 * 
 * 1) 页面地址不会增加 hash( 相较于 hash-mode 的页面地址好看一些 )
 * 
 * 2) 该模式访问未知页面，若没有后端配合，则会返回 404
 *    ( 若 url 匹配不到任何静态资源，则返回同一个 index.html )
 */


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

### use vue-router about html

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * html
 * 
 * 
 */

<div id="app">

    <h1>Hello App!</h1>
    
    <p>
    
        <!-- 使用 router-link 组件来导航.                 -->
        <!-- 通过传入 `to` 属性指定链接.                   -->
        <!-- <router-link> 默认会被渲染成一个 `<a>` 标签   -->
        
        <router-link to="/foo">Go to Foo</router-link>
        <router-link to="/bar">Go to Bar</router-link>
      
    </p>
    
    <!-- 路由出口 -->
    <!-- 路由匹配到的组件将渲染在这里 -->
    
    <router-view></router-view>
  
</div>


//-------------------------------------------------------------------------------------------------------------------//


/**
 * router-link class
 * 
 * 
 * router-link-exact-active         // 当前展示路径完全匹配组件to属性的值
 * 
 * router-link-active               // 当前展示路径包含to属性的值
 */


VueRouter({

  linkActiveClass: 'link-active',
  linkExactActiveClass: 'link-exact-active',
});


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
``` 

### named-router & nested-router & redirect & alias

#### named-router

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 命名路由
 * 
 * 
 * 通过给 路由命名，可以 html 中跳转时 以对象的形式直接使用已命名的路由
 */

routes = [

    {
        path: '/activity/personal',
        
        name: 'personal',                   // 路由命名
        
        component: Personal,
    }
];


<router-link :to="/activity/personal">个人中心</router-link>                // default

<router-link :to="{ name: 'personal' }">个人中心</router-link>              // use named routes


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### nested-router

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 嵌套路由
 * 
 * 
 * 被 router-view 渲染的组件想要包含自己的嵌套 router-view 时，可以使用嵌套路由
 */

{
  path: '/activity',

  component: () => import('./views/Activity'),
  
    children: [                                         // 嵌套路由
    
        {
            path: '/activity/academic',                 // before
            name: 'academic',
            component: () => import('./views/Academic'),
        },
        {
            path: '/personal',                          // afher: 子路由的路径可以简写
            name: 'personal',
            component: () => import('./views/Personal'),
        },
        {
            path: '/download',
            name: 'download',
            component: () => import('./views/Download'),
        }
    ],
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### router-redirect

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 重定向
 * 
 * 
 * { redirect: path | named-router | fn }
 * 
 * “重定向”的意思是，当用户访问 "/a" 时，URL 将会被替换成 "/b"，然后匹配路由为 "/b"
 */

const router = new VueRouter({

    routes: [
    
        { 
            path: '/a',
            
            redirect: '/b',                             // 路由路径

            redirect: { name: 'foo' },                  // 命名路由

            redirect: to => {                           // 方法
                
                // to: 接收 "目标路由" 作为参数
                
                // return: 重定向的 字符串路径/路径对象
            }
        }
    ]
});


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### router-alias

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 别名 
 * 
 * 
 * "/a" 的别名是 "/b", 当用户访问 "/b" 时，URL 会保持为 "/b"，但是路由匹配则为 "/a"
 */


const router = new VueRouter({

    routes: [
    
        { 
            path: '/a', 
            
            component: A, alias: '/b',                  // 别名
        }
    ]
});


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

### $router & $route

#### $router

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * $router                  // 路由实例对象
 * 
 * 
 * 除了使用 <router-link> 创建 a 标签来定义导航链接，我们还可以借助 router 的实例 方法，通过编写代码来实现
 */


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * 声明式 vs 编程式
 * 
 * 
 * 声明式: <router-link :to="...">
 * 
 * 编程式: this.$router.push(...)
 */


//-------------------------------------------------------------------------------------------------------------------//


/**
 * $router.push(targetRouter);
 * 
 * 
 * 想要导航到不同的 URL，则使用 router.push 方法
 */

// 字符串
this.$router.push('home');

// 对象
this.$router.push({ path: 'home' });

// 命名的路由
this.$router.push({ name: 'user' });


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * router.replace();
 * 
 * 
 * 跟 router.push 很像，唯一的不同就是，它不会向 history 添加新记录，而是替换掉当前的 history 记录
 */


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * $router.go(num);
 * 
 * 
 * 在 history 记录中向前或者后退多少步
 */

// 在浏览器记录中前进一步，等同于 history.forward()
this.$router.go(1);

// 后退一步记录，等同于 history.back()
this.$router.go(-1);

// 前进 3 步记录
this.$router.go(3);

// 如果 history 记录不够用，那就默默地失败呗
this.$router.go(-100);
this.$router.go(100);


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### $route

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * $route                       // 只读，路由信息对象
 * 
 * 
 * $route.path                  // string，对应当前路由的路径，总是解析为绝对路径，如 "/foo/bar"
 * 
 * $route.params                // { key: value }，包含了动态片段和全匹配片段，如果没有路由参数，就是一个空对象
 * 
 * $route.query                 // { key: value }，表示 URL 查询参数。例如，对于路径 /foo?user=1，则有 $route.query.user ==
 *                              // 如果没有查询参数，则是个空对象
 * 
 * $route.hash                  // string，路由的 hash 值 (带 #) ，如果没有 hash 值，则为空字符串
 * 
 * $route.fullPath              // 完成解析后的 URL，包含查询参数和 hash 的完整路径
 * 
 * $route.matched               // array，包含当前路由的所有嵌套路径片段的路由记录 
 *                              // 路由记录就是 routes 配置数组中的对象副本( 还有在 children 数组 )
 * 
 * $route.name                  // 当前路由的名称，如果有的话
 * 
 * $route.redirectedFrom        // 如果存在重定向，即为重定向来源的路由的名字
 */


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

### dynamic router

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * dynamic router
 * 
 * 
 * 同一父级路径下的所有子组件，指向并渲染同一个组件时，可以使用动态路由
 */

const User = {

    template: '<div>User</div>'
}


// {
//     path: '/course',
//     children: [                          // 代码冗余
//         {
//             path: '331578',
//             component: () => import('/views/About')
//         },
//         {
//             path: '231578',
//             component: () => import('/views/About')
//         },
//         {
//             path: '234178',
//             component: () => import('/views/About')
//         },
//         ...
//     ]
// }


const router = new VueRouter({

    routes: [
    
        {
            path: '/user/:id',              // 动态路径参数 以冒号开头
            
            component: User,
        }
    ]
});


User.mounted {                                      // 可以在 User 组件中获取 动态路径的参数

    console.log( this.$route.params);       // 动态路由的 动态路径参数

    // => { id: val }
    // 
    // @id: 动态路径参数
    // @val: 动态路径
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

### router-view

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * router-view
 * 
 * 
 * 同时展示多个视图时，并且每个视图展示不同的组件时，可以使用命名视图
 * 
 * 若 router-view 没有设置名字，那么默认为 default
 */


<router-view class="view one"></router-view>                        // name: defaule

<router-view class="view two" name="a"></router-view>               // 设置 路由命名
<router-view class="view three" name="b"></router-view>             // 设置 路由命名


const router = new VueRouter({

    routes: [
        {
            path: '/',
            
            components: {               // 多路由视图的  key 为 "components"
            
                default: Foo,
                
                a: Bar,                 // 指定 命名路由
                b: Baz                  // 指定 命名路由
            }
        }
    ]
})


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

### router navigator guard

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/** VueRouter 导航 & 守卫 **/

// 
//                  + ------ +                 + ------ + 
//                  |        |                 |        |       |
//                  |  from  |         |       |   to   |       |
//          |       |        |         |       |        |       |
//          |       + ------ +         |       + ------ +       |
//          |                          |                        |
// -------- + ------------------------ + ---------------------- + ------>
//          |                          |                        |
// 
//      beforeEach                beforeResolve             afterEach
//


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * 导航:          // 路由正在发生变化
 *
 * 守卫:          // 导航守卫主要用来通过跳转或取消的方式守卫导航
 *
 *
 * 导航 & 守卫:    // 全局的、单个路由独享的、组件内的
 */


//-------------------------------------------------------------------------------------------------------------------//


/** 全局守卫: 是指路由实例上直接操作的钩子函数，触发路由就会触发这些钩子函数 **/


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * beforeEach((to, from, next) => {             // 在路由跳转前触发，一般被用于登录验证
 *
 *     // ...
 *
 * });
 *
 *
 * @to:     目标路由对象
 * @from:   即将要离开的路由对象
 *
 * @next:   1) 必须调用next()，才能继续往下执行一个钩子，否则路由跳转会停止
 *
 *          2) 若要中断当前的导航，可以调用next(false)
 *
 *          3) 可以使用 next 跳转到一个不同的地址。终止当前导航，进入一个新的导航。
 *             next参数值 和 $routet.push 一致
 *
 *          4) next(error)。2.4+，如果传入的参数是一个Error实例，则导航会被终止，
 *             且该错误会被传递给router.onError() 注册过的回调
 *
 *
 * * next(); 必须执行
 */

router.beforeEach((to, from, next) => {

    console.log('router-beforeEach');

    next();

});


router.onError(err => {             // 获取错误信息

    console.log('err.message: ', err.message);
});


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * beforeResolve((to, from, next) => {          // 路由跳转前触发
 *
 *     // ...
 *
 * });
 *
 *
 * @to:     目标路由对象
 * @from:   即将要离开的路由对象
 *
 * @next:   1) 必须调用next()，才能继续往下执行一个钩子，否则路由跳转会停止
 *
 *          2) 若要中断当前的导航，可以调用next(false)
 *
 *          3) 可以使用 next 跳转到一个不同的地址。终止当前导航，进入一个新的导航。
 *             next参数值 和 $routet.push 一致
 *
 *          4) next(error)。2.4+，如果传入的参数是一个Error实例，则导航会被终止，
 *             且该错误会被传递给router.onError() 注册过的回调
 *
 *
 * * next(); 必须执行
 */

router.beforeResolve((to, from, next) => {

    // console.log('router-beforeEach');

    next();
});


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * afterEach((to, from) => {                // 路由跳转完成后触发
 *
 *     // ...
 *
 * });
 *
 *
 * @to:     目标路由对象
 * @from:   即将要离开的路由对象
 */

router.afterEach((to, from) => {

    // console.log('router-beforeEach');
});


//-------------------------------------------------------------------------------------------------------------------//


/** 路由独享守卫: 在单个路由配置的时候也可以设置的钩子函数 **/


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * beforeEnter((to, from, next) => {        // 和 beforeEach 完全相同，如果都设置则在 beforeEach 之后紧随执行
 *
 *     // ...
 *
 * });
 *
 *
 * @to:     目标路由对象
 * @from:   即将要离开的路由对象
 *
 * @next:   1) 必须调用next()，才能继续往下执行一个钩子，否则路由跳转会停止
 *
 *          2) 若要中断当前的导航，可以调用next(false)
 *
 *          3) 可以使用 next 跳转到一个不同的地址。终止当前导航，进入一个新的导航。
 *             next参数值 和 $routet.push 一致
 *
 *          4) next(error)。2.4+，如果传入的参数是一个Error实例，则导航会被终止，
 *             且该错误会被传递给router.onError() 注册过的回调
 *
 *
 * * next(); 必须执行
 */


//-------------------------------------------------------------------------------------------------------------------//


/** 组件内守卫: 在组件内执行的钩子函数，类似于组件内的生命周期，相当于为配置路由的组件添加的生命周期钩子函数 **/


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * beforeRouteEnter((to, from, next) => {           // 路由进入之前调用
 *
 *     // ...
 *     // axios(): required-data;                   // 因无法访问 this，则可以请求数据
 *
 *
 *     next(vm => {
 *
 *         vm.data = required-data;                 // 通过回掉访问 this，再存储数据
 *     })
 *
 * });
 *
 *
 * * 在该守卫内访问不到组件的实例，this值为undefined
 *
 * * 可以通过给 next(vm => {}); 传一个回调给 访问组件实例
 * * 在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数
 *
 * * 当成功获取并能进入路由时，调用next并在回调中通过 vm访问组件实例进行赋值等操作，
 * * ( next中函数的调用在mounted之后: 为了确保能对组件实例的完整访问 )
 */


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * beforeRouteUpdate((to, from, next) => {          // 在当前路由改变时
 *                                                  // 并且该组件被复用时调用
 *                                                  // 可以通过 this 访问实例
 *     // ...
 *
 * });
 *
 *
 * *  组件何时会被服用: 1) 动态路由间互相跳转
 * *                  2) 路由 query 变更时
 */


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * beforeRouteLeave((to, from, next) => {           // 导航离开该组件的对应路由时调用
 *                                                  // 可以访问组件实例this
 *
 *     // ...
 *
 * });
 *
 *
 */


//-------------------------------------------------------------------------------------------------------------------//


/** 完整的导航解析流程 **/


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * 01) 导航被触发
 *
 * 02) 在失活的组件里调用离开守卫
 *
 * 03) 调用全局的 beforeEach 守卫
 *
 * 04) 在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)
 *
 * 05) 在路由配置里调用 beforeEnter
 *
 * 06) 解析异步路由组件
 *
 * 07) 在被激活的组件里调用 beforeRouteEnter
 *
 * 08) 调用全局的 beforeResolve 守卫 (2.5+)
 *
 * 09) 导航被确认
 *
 * 10) 调用全局的 afterEach 钩子
 *
 * 11) 触发 DOM 更新
 *
 * 12) 用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数
 */


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

### router scrollBehavior

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * scrollBehavior(): { x, y };
 * 
 * 
 * @to: 目标路由对象
 * @from: 即将要离开的路由对象
 * 
 * @savedPosition: 当且仅当 popstate 导航 (通过浏览器的 前进/后退 按钮触发) 时才可用
 * 
 * 
 * return: 期望滚动到哪个的位置
 *         { x: number, y: number }
 *         { selector: string, offset? : { x: number, y: number }} (offset 只在 2.6.0+ 支持)
 */

scrollBehavior (to, from, savedPosition) {

    return { 
        x: 0, 
        y: 0,
    };
}



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```
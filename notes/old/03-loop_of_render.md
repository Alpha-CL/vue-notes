# vue-key of rerender

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


<ul id="app">
    <li v-for="(val, idx) in persons">
        {{ val }}
        <label>
            <input type="text"/>
            <button @click="handleClick(idx)">下移</button>
        </label>
    </li>
</ul>


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


Vue更新使用 v-for 渲染的元素列表时，默认使用 “就地更新” 的策略。如果数据项的顺序被改变，

Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处每个元素

在"就地复用"策略中，点击按钮，输入框不随文本一起下移，是因为输入框没有与数据绑定，所以 vue js 默认使用已经渲染的 dom，

然而文本是与数据绑定的，所以文本被重新渲染。这种处理方式在 vue 中是默认的列表渲染策略( 因为高效 )


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### in-place

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * in-place                         // 就地复用策略
 *
 *
 */

* 优点:

如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处每个元素

vue为了提升性能，不会移动dom元素，只是更新相应元素的内容节点


* 弊端:

这个默认的模式是高效的，但是只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### key: uid

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * key = UID: (num | str);           // 唯一标识节点加速虚拟DOM渲染
 *
 *
 */

1) 有相同父元素的子元素必须有独特的 key

2) 重复的 key 会造成渲染错误

3) key 是唯一的


//-------------------------------------------------------------------------------------------------------------------//


/**
 * :key = ID: str/num;              // key 是唯一的
 *
 *
 * 设置 唯一 key 值后，元素将会根据 唯一的 key 所渲染，而不是 默认的就近渲染
 *
 * 不建议使用 index，当重新渲染后，可能会覆盖之前同样 索引的元素，浪费性能消耗
 */


//-------------------------------------------------------------------------------------------------------------------//


/**
 * :key vs key
 *
 *
 * v-bind:key = val                 // 可利用 v-bind 动态绑定 key
 *
 * key = val
 */


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### key of virtual_dom

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * Virtual DOM
 *
 *
 *
 */

key主要作用于Vue的 Virtual DOM 算法，在 diff-new-nodes-list 和 old-nodes-list 时，作为识别 VNode 的一个线索

如果不用key，Vue会用一种算法：最小化element的移动，并且会尝试尽最大程度在同适当的地方对相同类型的element，做 patch 或者 reuse

如果使用key，Vue会根据 keys 的顺序记录element，曾经拥有了key的element如果不再出现的话，会被直接 remove 或 destoryed

拥有同一个parent的children必须有unique keys。重复的key的导致render error


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### v-for

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * v-for="[params...] in [target]"
 *
 *
 * 会强制替换元素
 */

v-for 渲染的元素列表时，默认使用 "就地更新" 的策略

若数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是简单复用就近的该元素


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### problem: v-for + v-if

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * v-for + v-if             // 性能消耗偏高
 *
 *
 * v-for 执行优先级较高，会优先执行 v-for 循环遍历之后，再对每个子项进行 v-if 判断
 *
 * 无论需要判断的是哪些条件，vue 都会将所有子项全部渲染一遍
 */


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### virtual_dom

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 什么是 virtual_dom
 * 
 * 
 */

1) virtual_dom 本质上就是一个 普通的 JS对象，运用描述视图的界面结构

2) 在 vue 中，每个组件都有一个 render(); 函数
    
    - 每个 render(): VNode; 函数都会返回一个 virtual_dom 

    - 每个组件都对应了一个 virtual_dom 

    - 若后续组件更新，则仅更新组件自身的 VNode


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * 为什么需要 virtual_dom
 * 
 * 
 * vue 使用 virtual_dom 代替 really_dom，主要为解决渲染效率
 */

在 vue 中，渲染视图会调用 render(); 函数，

    - 该渲染不仅发生在组件创建时
    
    - 同时发生在视图依赖的数据更新时候

若在渲染时，直接使用 really_dom

    - 由于创建 really_dom 的 创建，更新，插入等 户籍带来大量的性能效果，从而极大的降低渲染效率
    

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * virtual_dom 如何转换为 really_dom
 * 
 * 
 * 
 */





///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```



